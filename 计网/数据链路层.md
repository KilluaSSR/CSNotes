
> 数据链路层使用的信道主要有以下两种类型：
> 
> 1. **点对点信道**  
>    这种信道使用一对一的点对点通信方式。
> 
> 2. **广播信道**  
>    这种信道使用一对多的广播通信方式，因此过程比较复杂。  
>    广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。


### 数据链路层传送的内容是帧

- **网络层：**数据报**，  
- **链路层**：数据链路层负责将网络层的数据报封装成帧进行传输。  
- **物理层**：数据链路层将帧传递给物理层进行实际的信号传输。

### 数据链路层的三个基本问题

数据链路层协议有许多种，但有三个基本问题是共同的：

1. **封装成帧**  
   发送方要让接收方知道所发送的帧从什么地方开始，什么地方结束。

2. **透明传输**  
   传送的比特组合不受限制，即比特流中的所有数据都能被正确传输，不会被解释或改变。

3. **差错控制**  
   判断数据传输是否正确，确保数据在传输过程中没有发生错误。

#### 1. 封装成帧

**封装成帧 (Framing)** 就是在一段数据的前后分别添加**首部**和**尾部**，然后就构成了一个帧，用来确定帧的界限。

- **首部和尾部的作用**：  
  其一个重要作用是进行帧定界。帧的发送从帧首部开始，帧的结束由帧尾部标识。

- **帧的结构**：  
  - **帧首部**：帧的开始部分。  
  - **数据部分**：承载实际数据（例如网络层的数据报）。  
  - **帧尾部**：帧的结束部分，通常用于标识帧的终止。

- **帧长度和MTU**：  
  数据链路层的帧长度应小于链路层协议规定的**最大传送单元 (MTU)**，即数据部分相对于首部和尾部尽可能大，以提高传输效率。

##### 用控制字符进行帧定界的方法

当数据是由可打印的 ASCII 码组成的文本文件时，可以使用特殊的帧定界符来进行帧定界。

- **控制字符 SOH (Start of Header)**：  
  SOH 放在一帧的最前面，表示帧的首部开始。

- **控制字符 EOT (End of Transmission)**：  
  EOT 表示帧的结束。

**帧定界示例**：
- **SOH**：表示帧的开始，十六进制编码为 `01`。
- **EOT**：表示帧的结束，十六进制编码为 `04`。

**作用**：  
- 使用 SOH 和 EOT 控制字符进行帧定界，可以明确区分每一帧的数据部分，避免出现发送中断等故障时的数据混乱。

#### 2. 透明传输

如果数据中的某个字节的二进制代码恰好与 **SOH** 或 **EOT** 相同，数据链路层可能会错误地“找到帧的边界”，从而导致数据传输出现问题。

- 例如，当数据中的内容恰好和 **EOT** 一样时，接收端可能误认为这是一个帧的结束符，导致帧被截断或丢弃。
  
- 在这种情况下，**EOT** 被接收端误认为是一个帧的结束符，结果数据部分被当作无效帧而丢弃。


**解决方法**：  

当数据中出现控制字符如 **SOH** 或 **EOT** 时，数据链路层可以通过字节填充或字符填充的方法来解决冲突问题。具体方法如下：

1. **字节填充**：
   - 如果数据中出现控制字符 **SOH** 或 **EOT**，则在这些字符前面插入一个转义字符 **ESC**（其十六进制编码为 `1B`）。
   - 接收端在将数据传递给网络层之前，会删除插入的 **ESC** 转义字符。

2. **转义字符的处理**：
   - 如果转义字符 **ESC** 本身也出现在数据中，那么在 **ESC** 前面还需再插入一个转义字符 **ESC**。
   - 接收端在收到连续的两个 **ESC** 字节时，删除前一个 **ESC** 字符，保留后一个。

- 假设数据中有控制字符 **SOH** 或 **EOT**，则发送端会将它们前面加上一个 **ESC**。
- 接收端在处理时会删除这些 **ESC** 字符，恢复原始数据。

#### 3. 差错检测

在数据传输过程中，可能会产生比特差错：
- **1** 可能会变成 **0**，而 **0** 也可能变成 **1**。

在一定时间内，传输错误的比特占所传输比特总数的比率称为 **误码率 (BER, Bit Error Rate)**。

- **误码率与信噪比有很大的关系**。

为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。

##### 循环冗余检验 (CRC) 的原理

在数据链路层传送的帧中，广泛使用了 **循环冗余检验 (CRC)** 的检错技术。

1. **数据划分**：
   - 在发送端，首先将数据划分为若干组。
   - 假定每组包含 **n** 个比特。
   - 假设待传送的数据组为 **M = 101001**（假设 **n = 6**）。

2. **冗余码的计算**：
   - 用二进制的模2运算进行 **2n 乘 M** 的运算，相当于在 **M** 后面添加 **n** 个 **0**。
   - 得到的 **(k + n)** 位数除以事先选定好的 **(n + 1)** 位的除数 **P**，得到商 **Q** 和余数 **R**。
   - 余数 **R** 的位数比除数 **P** 少 1 位，即 **R** 是 **n** 位。
   - 将余数 **R** 作为冗余码，拼接在数据 **M** 后面进行发送。

3. **帧检验序列 (FCS)**：
   - 在数据后面添加的冗余码称为 **帧检验序列 (FCS, Frame Check Sequence)**。

- **FCS** 可以通过 **CRC** 方法得出，但 **CRC** 并不是获得 **FCS** 的唯一方法。

**CRC 差错检测的结果判断**：
1. 
   - **若余数 R = 0**，则判定该帧没有差错，可以接受（**accept**）。
   - **若余数 R ≠ 0**，则判定该帧有差错，应丢弃。

2. **差错检测的局限性**：
   - 循环冗余检验（CRC）不能确定具体是哪一个或哪些比特发生了差错。
   - 只要经过严格挑选，并使用足够长的除数 **P**，出现检测不到的差错的概率非常小。

3. **无差错接受**：
   - **CRC 差错检测技术**只能做到 **无差错接受 (accept)**。
   - “无差错接受”是指：凡是接收端接受的帧（即不包括丢弃的帧），我们可以以接近 1 的概率认为这些帧在传输过程中没有产生差错。
   - 换句话说：“凡是接收端数据链路层接受的帧，都认为没有发生传输差错。”有差错的帧会被丢弃而不被接受。

4. **可靠传输**：
   - 要实现 **可靠传输**（即发送的内容与接收的内容完全一致），必须在数据链路层之外再增加确认和重传机制。
   - 在数据链路层使用 **CRC** 检验能够实现无比特差错的传输，但这还不能确保完全的可靠传输。