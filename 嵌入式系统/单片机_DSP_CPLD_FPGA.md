
## 51单片机

![[Pasted image 20250419061029.png]]

它有：
- 一个 8位算术逻辑单元
- 32个I/O口、4组8位
- 两个16位定时计数器
- 全双工串行通信
- 5个中断源
- 128字节RAM
- 64K字节独立数据代码区

| 存储区   | 描述                                                     |
| :---- | :----------------------------------------------------- |
| DATA  | RAM 的**低 128 个字节**，可在一个周期内直接寻址                         |
| BDATA | DATA 区的 16 个字节的可位寻址区                                   |
| IDATA | RAM 区的**高 128 个字节**，必须采用间接寻址                           |
| PDATA | 外部存储区的 256 个字节，通过 P0 口的地址对其寻址，使用指令 MOVX @Rn, 需要两个指令周期。 |
| XDATA | 外部存储区，使用 DPTR 寻址                                       |
| CODE  | 程序存储区，使用 DPTR 寻址                                       |

### 特殊功能寄存器 SFR 区（80H--FFH）

| 寄存器  | 描述          | 地址  | 寄存器  | 描述      | 地址  |
| :--- | :---------- | :-- | :--- | :------ | :-- |
| ACC  | 累加器         | E0H | IE   | 允许中断控制  | A8H |
| B    | B寄存器        | F0H | TMOD | 定时方式控制  | 89H |
| PSW  | 程序状态字       | D0H | TCON | 定时/计数控制 | 88H |
| SP   | 堆栈指针        | 81H | TH0  | T0高字节   | 8CH |
| DPTR | 数据指针DPH、DPL | 82H | TL0  | T0低字节   | 8AH |
| P0   | P0口         | 80H | TH1  | T1高字节   | 8DH |
| P1   | P1口         | 90H | TL1  | T1低字节   | 8BH |
| P2   | P2口         | A0H | SCON | 串行控制    | 98H |
| P3   | P3口         | B0H | SBUF | 串行数据缓冲器 | 99H |
| IP   | 中断优先级控制     | B8H | PCON | 电源控制    | 97H |

### 时序

- 单片机的时序定时单位共有４个，从小到大依次是：

	- 振荡周期：即晶振的周期也叫时钟周期；
	
	- 状态周期：一个状态周期等于两个振荡周期;
	
	- 机器周期：一个机器周期等于六个状态周期;
	
	- 指令周期：CPU执行一条指令所用的时间。


## DSP

```mermaid
graph LR
    A[模拟信号] --> B[ADC]
    B --> C[数字信号处理器DSP]
    C --> D[DAC]
    D --> E[数字信号]
```

### 并行处理技术

| 并行类型    | 描述                                                             |
| :------ | :------------------------------------------------------------- |
| 时间并行    | 让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部件，以此获得时间上的重叠。实现方式就是采用流水处理部件。 |
| 空间并行    | 资源重复；以数量取胜；它独享实体资源。                                            |
| 时间-空间并行 | Pentium 中采用了这种流水线技术。                                           |

- **CPU 流水线结构**:
    - 分为三级流水线：
        - **指令部件**: 负责取指。
        - **指令队列**: 负责译码。
        - **执行部件**: 负责执行。

- **流水线在乘法累加运算中的优势**:
    - 利用这种流水线结构，加上执行重复操作，可以保证数字信号处理中常用的乘法累加运算在单个指令周期内完成。

- **指令流水线的总体优势**:
    - 指令流水线的主要作用是减少指令的平均执行时间，提高CPU的吞吐率。

- **片内总线结构**:
    - 片内有多条独立的地址总线、数据总线和控制总线，支持并行数据传输，有助于流水线高效工作。


![[Pasted image 20250419063402.png]]

* **CLKOUT**: 处理器输出的时钟信号。
* **流水线阶段**: 
    * **取指**: 从内存中取出下一条指令。
    * **译码**: 解释指令的含义，确定需要执行的操作和操作数。
    * **执行**: 执行指令指定的操作（如算术运算、数据传输等）。
* **指令编号**: `N`, `N+1`, `N+2` 等代表不同的指令序列。`N-1`, `N-2` 代表在当前时刻之前进入流水线的指令。

从图中可以看出，在任何一个时钟周期内，流水线中的不同阶段都在处理不同的指令：
* 当指令 `N` 处于**执行**阶段时，
* 指令 `N-1` 处于**译码**阶段，
* 指令 `N-2` 处于**取指**阶段。

在下一个时钟周期，所有指令向前移动一个阶段：

* 指令 `N` 可能完成执行，
* 指令 `N-1` 进入**执行**阶段，
* 指令 `N-2` 进入**译码**阶段，
* 新的指令 `N+1` 进入**取指**阶段。

这种重叠处理的方式使得处理器可以在每个时钟周期完成一个指令的**执行**，而不是等待一条指令完全通过所有阶段后再开始下一条。


#### Q：哪个结构更适合实现指令流水线技术？

> 答案是：**哈佛结构 (Harvard Architecture)** 更适合实现指令流水线技术。

指令流水线技术的核心思想是将指令执行过程分成多个阶段，并让不同的指令在同一时间处于不同的阶段并行处理。常见的流水线阶段包括：取指、译码、执行、访存、写回。

在流水线执行过程中，经常需要在某个阶段取下一条指令（取指），同时在另一个阶段访问数据（访存或写回）。

- 在**冯诺依曼结构**中，由于指令和数据共用总线，取指令和访存数据会相互冲突，导致流水线必须停顿，等待总线空闲。
- 在**哈佛结构**中，由于指令总线和数据总线是分开的，**取指令和访存数据可以真正地同时进行**，消除了总线冲突带来的流水线停顿。以三级流水线为例，**要求CPU在同一个时钟周期内，同时进行取指、译码、执行操作**。这要求同一个周期可以**同时进行对程序空间访问与对数据空间的访问**。因此，**哈佛结构具有不同的访问总线**，是构建指令流水线的必要条件。

因此，哈佛结构固有的指令和数据并行访问能力，使其在实现高性能指令流水线方面具有显著优势。许多现代的处理器（特别是数字信号处理器 DSP 和微控制器 MCU）为了提高性能，都倾向于采用改进型的哈佛结构。

#### 冯诺依曼架构 x86 CPU 如何解决流水线中的访存冲突问题

> x86 系列 CPU 采用冯诺依曼结构，程序和数据共用同一物理存储器和总线。在指令流水线中，可能出现同时访问程序存储器（取指令）和数据存储器（访存操作）的情况，这可能导致冲突并影响性能。如何解决？

**解决方案**:

1.  **分离缓存 (Separated Caches)**:
    * x86 CPU 通常有多级缓存 (L1, L2, L3)。
    * 其中，L1 缓存通常被分为**指令缓存**和**数据缓存**。
    * 这样可以分开访问指令和数据，从而减少访问冲突和竞争。

2.  **指令预取技术 (Instruction Prefetching)**:
    * CPU 会使用指令预取技术，提前将下一条指令从内存读取到缓存中。
    * 这减少了对主内存的访问频率，即使同时访问程序存储器和数据存储器，也能减少竞争和冲突。

3.  **乱序执行技术 (Out-of-Order Execution)**:
    * x86 CPU 的乱序执行技术允许 CPU 不按照指令在程序中的顺序执行。
    * 这有助于避开数据依赖和资源竞争导致的停顿，提高执行效率。

4.  **内存分段技术 (Memory Segmentation)**:
    * x86 CPU 的内存分段技术可以将内存地址空间划分为多个段。
    * 程序和数据可以分别存储在不同的内存段中。
    * 这有助于组织内存访问，从而减少冲突和竞争（尽管其主要目的是内存管理和保护，但对访存冲突缓解有间接作用）。


### 程序启动

- 在 TMS320F28XXX 系列 DSP 上，从内部 Flash 运行代码的速度通常比从内部 RAM 运行要慢，大约慢 30% 左右。
- 因此，对于对运行时间有严格要求的程序（即时间苛刻的程序），直接在 Flash 中运行可能无法满足性能需求。
- 为了提高运行速度，通常需要将这些对性能要求高的代码从 Flash 拷贝（加载）到速度更快的内部 RAM 中执行。

### Direct Memory Access(DMA技术)

- **定义**: DMA 是一种机制，允许计算机的外设（如硬盘、网卡、声卡等）与存储器之间，或者存储器与存储器之间直接进行数据交换，而无需 CPU 的不断干预。
    
- **工作原理**:
    
    - 在 DMA 方式下，DMA 控制器 (DMAC) 负责管理数据传输。
    - 当需要进行数据传输时，CPU 会向 DMA 控制器发送指令，告诉它传输的源地址、目标地址、数据量和传输方向。
    - 一旦设置完成，DMA 控制器会获得系统的总线控制权（CPU 会暂时释放总线）。
    - DMA 控制器直接操纵数据在存储器和外设之间（或存储器之间）进行高速传输，整个过程不需要 CPU 执行每一步数据存取的指令。CPU 在此期间可以去执行其他任务。
    - 数据传输完成后，DMA 控制器会发出中断信号通知 CPU。
- **常见的 DMA 数据传输方向**:
    
    1. **RAM → I/O**: 从内存传输数据到外设（例如，发送数据到网卡）。
    2. **I/O → RAM**: 从外设传输数据到内存（例如，从硬盘读取数据到内存）。
    3. **RAM ←→ RAM**: 在内存的不同区域之间进行数据拷贝。
![[Pasted image 20250419064613.png]]

### Q：说说DSP的主要特点？

> **哈佛总线结构**，系统实时性好。
> **分开的地址空间**
> **指令流水线技术**，减少了指令执行时间
> **具有独立乘法器**
> **在ROM存储，RAM执行，支持多种BOOT方式**
> **DMA技术**，DMA控制器拥有总线控制权，操纵数据在存储器与外设之间直接传送，不需要CPU执行指令
> **片内数字锁相技术**，片内高频，片外低频，利于系统稳定。
### 与单片机对比

| 特点            | DSP 处理器                                                | 单片机                                                |
| :------------ | :----------------------------------------------------- | :------------------------------------------------- |
| **核心功能/主要应用** | 针对高速数字信号处理设计 (如音频、语音、图像、通信、控制算法中的高速计算)                 | 侧重于设备控制、状态监测、外设管理和简单计算 (如家电、汽车电子、工控)               |
| **运算能力**      | 具有高速乘法器和累加器 (MAC)、专门的 DSP 指令集，擅长并行和重复性数值运算，计算密集型任务性能高。 | 通用性计算，运算能力相对较低，不擅长大规模、高速的重复性数值运算。                  |
| **指令集**       | 包含大量针对数字信号处理优化的专用指令，如单周期 MAC 指令、循环零开销指令等。              | 主要为通用的算术、逻辑、控制、数据传输指令。                             |
| **存储器结构**     | 常采用哈佛或改进型哈佛结构，指令和数据分开存取，通常有多组独立存储器（如片内高速 RAM），支持并行访问。  | 多采用冯诺依曼结构（指令和数据共用总线），结构相对简单，访存可能成为瓶颈（现代单片机有缓存或改进）。 |
| **I/O 接口**    | 侧重于与信号相关的接口，如高速 ADC/DAC、同步串行接口 (McBSP) 等。              | 侧重于通用控制接口，如 GPIO、UART、SPI、I2C、定时器、中断控制器等。          |
| **流水线**       | 通常具有较深、高效的指令流水线，以支持高速指令执行。                             | 流水线深度通常较浅或没有流水线，执行速度相对较慢。                          |
| **开发环境**      | 提供专业的开发工具链，包括针对 DSP 算法优化的编译器、仿真器、性能分析工具等。              | 提供通用的嵌入式开发工具链，侧重于外设驱动、实时操作系统 (RTOS) 支持等。           |
| **功耗**        | 在高性能运行时功耗可能较高。                                         | 通常设计为低功耗，适合电池供电的应用。                                |
## CPLD与FPGA

### 二者的区别

- **存储/编程方式**：
    - **CPLD** (通常基于 EEPROM/Flash): **编成后逻辑固定在芯片内部，掉电不丢失**，上电即可工作。
    - **FPGA** (通常基于 SRAM): 掉电易失，**需要从外部EPROM加载配置数据**（即“启动” boot），然后逻辑在内部 SRAM 中建立，掉电后 RAM 逻辑丢失。
- **架构 (Architecture)**：
    - **CPLD**: 基于乘积项 (Product Term) 和宏单元 (Macrocell) 结构，逻辑阵列相对固定，更适合实现较宽的组合逻辑。
    - **FPGA**: 基于查找表 (LUT) 和可配置逻辑块 (CLB)，逻辑资源分布更细粒度、更灵活，适合实现复杂的时序逻辑和算术逻辑。
- **资源能力 (Capacity/Resources)**：
    - **FPGA**: **比 CPLD 的能力与资源更强**。包含的逻辑单元（如 LUT、寄存器）、内置存储器块 (Block RAM)、硬件乘法器/DSP 单元等资源远多于 CPLD，适合实现大规模、复杂逻辑功能。
    - **CPLD**: 资源相对较少，适合实现中小规模逻辑。
- **布线/时序 (Routing/Timing)**：
    - **CPLD**: 布线资源相对固定可预测，适合实现快速、时序严格的简单组合逻辑，延迟可预测性好。
    - **FPGA**: 布线资源丰富但层级复杂，时序分析和优化难度相对较大，但经过优化可以实现更高工作频率的复杂时序逻辑。
- **应用场景 (Applications)**：
    - **CPLD**: 常用于“胶合逻辑”(Glue Logic)、地址译码、简单的状态机、上电启动配置 (boot logic)、接口转换等，对时序的确定性要求较高。
    - **FPGA**: 适用于复杂的数字信号处理、高速接口协议处理、大规模并行运算、系统原型验证、定制计算等，实现功能复杂度更高。