## Q1

> 有一个四字节的`int`变量，值为`0x12345678`，已知此变量的内存地址为`p`，则大小端编译环境下，`p+1`，`p+2`，`p+3`，`p+4`里的字节值分别是？

### A1

|     | p        | p+1      | p+2      | p+3      |
| --- | -------- | -------- | -------- | -------- |
| 大端  | 0x12     | 0x34     | 0x56     | 0x78     |
| 小端  | **0x78** | **0x56** | **0x34** | **0x12** |

--- 
## Q2

> 简述哈佛结构和冯诺伊曼结构的区别，并说明如何利用其中一种结构简单实现指令流水线？

### A2

- 哈佛结构：程序存储区域与数据存储区域分开，独立编址，用不同的总线访问。
- 冯诺伊曼结构：程序存储区域与数据存储区域不分开，统一编址、用相同总线访问。
- 使用哈佛结构：以三指令为例、同一指令周期中，要进行取指（N）、译码（N-1）、执行操作（N-2）。需要同时访问程序存储区域和数据存储区域。因此，必须要是用不同的总线访问才能实现。

---
## Q3 

> RISC和CISC指令集有什么区别？ARM使用的是哪种，有什么好处？

### A3

- RISC：精简指令集计算机。它的指令长度固定、指令执行周期一致。
- CISC：复杂指令集计算机。它的指令长度不固定、指令执行周期有长有短。
- ARM使用的是RISC。其中，ARM的R即为RISC。**将指令长度固定，指令格式和寻址方式种类减少**。RISC在通道中只包含最有用的指令，确保数据通道快速执行每一条指令，使CPU硬件结构设计变得更为简单。

---

## Q4

> 简述`uCos-II`如何管理就绪表？

### A4

- `uCOS-II` 使用一套两级位图结构来高效管理所有任务的就绪状态，并能非常快速地找到当前处于就绪状态的最高优先级的任务。

1. **`OsRdyTbl` (就绪表):** 直接映射到所有可能的任务优先级（0 到 63）。`OsRdyTbl[i]` 的第 `j` 个比特位为 1 表示优先级为 `(i * 8) + j` 的任务处于就绪状态，为 0 则表示该优先级无就绪任务。
2. **`OsRdyGrp` (就绪组):** 每个比特位**对应** `OsRdyTbl` 中的一个字节（即一个优先级组）。如果 `OsRdyTbl[i]` 这个字节中有任何一个比特位被置为 1（表示第 `i` 组优先级中有任务就绪），那么 `OsRdyGrp` 的第 `i` 个比特位就会被置为 1。
3. **查找过程:** 当需要调度任务时，`uCOS-II` 首先查找 `OsRdyGrp` 中最低的置位（为 1）的比特位，这通过预先计算好的查找表 `OsUnMapTbl` 快速完成。这个比特位的索引（0-7）就是当前有就绪任务的最高优先级**组**的索引。然后，根据这个组索引找到 `OsRdyTbl` 中对应的字节，再次使用 `OsUnMapTbl` 查找该字节中最低的置位比特位，这个比特位的索引（0-7）就是该组内最高优先级任务的偏移量。将组索引乘以 8 加上组内偏移量，即可得到全局最高优先级就绪任务的优先级数值。

- `OsRdyTbl` 存储每个优先级的详细就绪状态，而 `OsRdyGrp` 则快速指示哪些优先级组包含就绪任务，通过这两级结构和查找表，实现了常数时间（或接近常数时间）的最高优先级查找。


---
## Q5

> 简述可编程逻辑器件与传统CPU器件的区别与联系。

### A5

- 区别：

	- 可编程逻辑器件一般由大量的与或非门、一些寄存器构成。依靠硬件描述语言来构建芯片内部电路逻辑。
	- CPU类的微控制器主要由控制器、运算器构成，能读取指令，对指令译码，并执行指令。

- 联系：

	- 都能体现嵌入式系统智能特征。

---
## Q6

> 已知：`short int`为`2字节`，`char`为`1字节`，`int`为`4字节`，采用4字节对齐。某个结构体成员依次为如下代码。声明了一个此结构体变量，且它的内存地址是`p`，分别指出各个成员的内存地址。

```c
short int a;
char b;
int c;
char d;
int e;
```

### A6

|  **p**  | **a0** | **a1** | **b**  |   /    |
| :-----: | :----: | :----: | :----: | :----: |
| **p+1** | **c1** | **c2** | **c3** | **c4** |
| **p+2** | **d**  |   /    |   /    |   /    |
| **p+3** | **e1** | **e2** | **e3** | **e4** |

---
## Q7

> 为什么一个函数访问全局变量，就无法重入？举例说明。

### A7

- 一个函数访问全局变量会使其**不可重入（Non-reentrant）**，因为多个并发调用会互相干扰对这个共享全局状态的读写。

- **举例：** 如果一个函数读取一个全局计数器，将其加一，再写回去，当两个任务同时调用此函数时，可能会读到同一个旧值，最终只将计数器增加了 1 次，而不是 2 次。

---
## Q8

> 简述`OsRdyGrp`、`OsRdyTbl`、`OsUnMapTbl`的作用，简述以下代码的作用，并说明：相比循环查找，以下代码有什么优点？

```c
y = OsUnMapTbl[OsRdyGrp];
x = OsUnMapTbl[OsRdyTbl[y]];
prio = (y << 3) + x;
```

### A8

- `OsRdyGrp`的每个比特位用作一个标志，对应 `OsRdyTbl` 数组中的一个字节（即一个优先级组，通常包含 8 个优先级）。如果 `OsRdyTbl` 的第 `i` 个字节中有任何比特位被置为 1（表示优先级 `i*8` 到 `i*8+7` 这一组中有任务就绪），则 `OsRdyGrp` 的第 `i` 个比特位被置为 1；否则置为 0。它提供了一个快速的方法来判断哪些优先级组中有就绪任务。
- `OsRdyTbl`的作用是：作为8字节数组一共有64个比特位。每个比特位表示每个优先级是否有任务就绪。有则置1，否则置0。
- `OsUnMapTbl`的作用是：利用空间换时间。记录0-255的二进制数中，最低位的1出现在哪里。如`OsUnMapTbl[129] = 0, OsUnMapTbl[128] = 7。 
- 代码的作用是**查找最高优先级任务**。
- **相比循环查找，以下代码的优点：** 这种方法通过查表和位运算，能够在**常数时间**内（即执行时间固定，不随任务数量或优先级范围变化而显著变化，通常只需要几次内存访问和简单的 CPU 指令）找到最高优先级任务。 而传统的循环查找方法，需要从最高优先级（通常是 0）开始逐个检查每个优先级在 `OsRdyTbl` 中的状态，直到找到第一个置为 1 的比特位。在最坏情况下（例如，只有优先级最低的任务就绪），可能需要检查全部 64 个比特位，其执行时间与优先级数量成**线性关系**。 因此，查表法相比循环查找，执行速度更快且可预测，这对于需要严格时间保证的实时操作系统至关重要。

---
## Q9 

> 嵌入式系统里的优先级反转是如何形成的？一般如何解决？

### A9

- 形成：
	- 在占先式多任务系统中，由于对共享资源的访问（如互斥锁），一个高优先级的任务被一个或多个中等优先级的任务间接阻塞，导致优先级顺序被“颠倒”的现象。高优先级任务等待低优先级任务释放资源，而低优先级任务又被中等优先级任务占先，使得高优先级任务无法执行。

- 解决方法：
	- 优先级继承
	- 优先级极限
	- `OsChangePrio`函数

---
## Q10

> 简述DSP在保证完成高速数据处理方面有什么改进。

## A10

- **内部PLL、独立乘法器、流水线技术、哈佛结构、DMA技术。**

---
## Q11

> 以下关于实时系统的描述，正确的是：
> 
> A. 运行快的系统比运行慢的实时性好 
> B. 软实时的需求得不到满足会发生灾难性后果 
> C. 若有嵌入式系统必须是实时操作系统 
> D. 实时操作系统必须是占先式内核

### A11

**D. 实时操作系统必须是占先式内核**。

---
## Q12

> 在`uCOS-II`中有`0-63`共64个优先级分配。现在，`OsRdyTbl[3] = 112(01110000)`，`OsRdyGrp = 104(01101000)`。计算目前就绪的任务里优先级最高的任务的优先级。

### A12

- 在 uCOS-II 中，优先级数值越小，优先级越高（0 是最高优先级，63 是最低优先级）。
1.  **确定最高优先级所在的组：** 查看 `OsRdyGrp = 104`。其二进制表示为 `01101000`。`OsRdyGrp` 的每个比特位代表一个优先级组。从右往左看（最低位是第 0 位），`01101000` 中最低的置位（为 1）的比特位是第 `3` 位（对应数值 8）。这表示当前有就绪任务的最高优先级组是索引为 3 的组。 
2.  **确定组内最高优先级任务的偏移：**  `OsRdyTbl[3]`，存储了第 3 组优先级的就绪状态。`OsRdyTbl[3] = 112`。其二进制表示为 `01110000`。在这个字节中，从右往左看（最低位是第 0 位），最低的置位（为 1）的比特位是第 `4` 位（对应数值 16）。这表示在第 3 组优先级中，优先级最高的就绪任务在该组内的偏移量是 4。
3.  **计算全局优先级：** 最高优先级任务的全局优先级可以通过以下公式计算： 全局优先级 = `组索引 * 8 + 组内偏移量` 根据上面的分析： 组索引 = 3 组内偏移量 = 4 全局优先级 = `3 * 8 + 4 = 24 + 4 = 28`。