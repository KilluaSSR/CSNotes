# Socket 网络编程

## TCP Socket 编程基础流程

**面试官：能描述一下 TCP Socket 的基本编程流程吗？**

**服务端流程：**
1. **创建Socket**：`socket()` 创建套接字，指定协议族和传输协议
2. **绑定地址**：`bind()` 绑定本地IP和端口，让系统知道数据发给哪个程序
3. **开始监听**：`listen()` 进入监听状态，内核开始接受连接请求
4. **接受连接**：`accept()` 从已完成的连接队列中取出客户端连接
5. **数据传输**：使用返回的新socket进行 `read()/write()` 操作

**客户端流程：**
1. **创建Socket**：同样调用 `socket()` 创建套接字
2. **发起连接**：`connect()` 指定服务端地址，触发三次握手

**关键概念：**
- 监听socket：用于接受新连接
- 连接socket：用于具体的数据传输
- 半连接队列：三次握手未完成的连接
- 全连接队列：已建立的连接，等待accept取走

## 并发连接处理方案

**面试官：如何让服务器同时处理多个客户端？**

### 1. 多进程方案
- **原理**：每个客户端连接fork一个子进程处理
- **优点**：进程隔离，一个崩溃不影响其他
- **缺点**：
  - 进程创建销毁开销大
  - 内存占用高（每个进程独立地址空间）
  - 进程切换成本高
  - 需要处理僵尸进程问题
- **适用场景**：连接数较少（<100）的场景

### 2. 多线程方案
- **原理**：每个连接创建一个线程，配合线程池减少创建销毁开销
- **优点**：比进程轻量，共享内存空间
- **缺点**：
  - 线程安全问题
  - 内存共享带来的复杂性
  - 仍有上下文切换开销
- **适用场景**：中等规模并发（数百到数千）

### 3. I/O多路复用（最重要）
- **核心思想**：一个线程监控多个socket，哪个有事件就处理哪个
- **解决的问题**：避免为每个连接创建线程/进程

## I/O多路复用技术对比

**面试官：select、poll、epoll 有什么区别？**

### select 的局限性
- **文件描述符限制**：最多1024个
- **性能问题**：每次调用都要：
  - 将fd_set从用户态拷贝到内核态
  - 内核遍历所有fd检查事件
  - 将结果拷贝回用户态
  - 用户态再次遍历找到就绪的fd
- **时间复杂度**：O(n)

### poll 的改进
- **突破数量限制**：使用链表存储，理论上无限制
- **仍有的问题**：还是需要拷贝和遍历，本质问题未解决

### epoll 的优势（重点）
- **高效的数据结构**：内核使用红黑树管理fd，增删查O(logn)
- **事件驱动机制**：只返回有事件的fd，避免遍历
- **减少拷贝**：通过epoll_ctl一次性注册，epoll_wait只返回就绪事件
- **支持大并发**：能轻松处理C10K问题

**epoll三个关键函数：**
- `epoll_create()`：创建epoll实例
- `epoll_ctl()`：注册/修改/删除要监听的fd
- `epoll_wait()`：等待事件发生

## epoll 工作模式

**面试官：epoll的ET和LT模式有什么区别？**

### 水平触发（LT - Level Triggered）
- **特点**：只要缓冲区有数据就会持续通知
- **优点**：编程简单，不容易丢失数据
- **缺点**：可能产生大量重复通知

### 边缘触发（ET - Edge Triggered）
- **特点**：只在状态变化时通知一次
- **要求**：必须一次性读完所有数据，通常配合非阻塞I/O
- **优点**：减少系统调用次数，性能更高
- **应用**：Nginx等高性能服务器

**为什么ET要配合非阻塞I/O？**
因为要一次性读完数据，如果用阻塞I/O，当没有数据时会卡住整个程序。

## 服务器连接数限制

**面试官：一台服务器理论上能支持多少TCP连接？**

**理论极限：**
- TCP连接由四元组唯一标识：(本地IP, 本地端口, 远程IP, 远程端口)
- 服务器IP和端口固定，变化的是客户端IP和端口
- 理论最大值：2^32 × 2^16 = 2^48 个连接

**实际限制：**
1. **文件描述符限制**：每个连接需要一个fd，默认1024个
2. **内存限制**：每个连接约占用几KB内存
3. **CPU处理能力**：上下文切换和数据处理能力

**优化方向：**
- 调整系统参数（ulimit）
- 使用epoll等高效I/O模型
- 优化应用层协议和数据处理逻辑

## 实际应用建议

**面试官：在实际项目中如何选择并发模型？**

1. **低并发（<100）**：多线程 + 阻塞I/O
2. **中等并发（100-1000）**：线程池 + 非阻塞I/O
3. **高并发（>1000）**：epoll + 非阻塞I/O + 事件驱动
4. **超高并发**：考虑Reactor/Proactor模式，或使用成熟框架

**关键要点：**
- 非阻塞I/O几乎总是更好的选择
- epoll是Linux下处理高并发的标准方案
- 理解每种方案的适用场景和限制条件