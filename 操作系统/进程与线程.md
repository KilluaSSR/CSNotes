
## 进程 (Process)

### 定义与组成

**进程**：是计算机中**程序**在**执行**时的一个实例。它不仅仅是程序代码本身，还包括了程序执行时所需的所有资源和状态。

**组成部分**：

- **静态部分**：
    - **程序代码 (Text Segment)**：程序的指令集。
    - **静态数据 (Data Segment)**：全局变量和静态变量。
- **动态部分**：
    - **堆 (Heap)**：动态分配的内存区域，由程序在运行时管理（`malloc`, `new` 等）。
    - **栈 (Stack)**：用于存储局部变量、函数参数、返回地址等。每个线程有自己的栈。
    - **进程状态**：包括程序计数器 (PC)、栈指针 (SP)、通用寄存器等，反映了程序执行的当前点和状态。
    - **其他资源**：文件描述符表、信号处理信息、内存管理信息等。

### 虚拟地址空间

- 每个进程都拥有**独立且私有**的**虚拟地址空间**。
- 这种独立性为进程提供了**独占全部内存的假象**，增强了隔离性和安全性。
- 虚拟地址空间通常被划分为用户空间和内核空间。
    - **用户空间**：存放用户程序的代码、数据、堆、栈等。不同进程的用户空间是隔离的。
    - **内核空间**：存放操作系统内核的代码和数据。虽然所有进程共享同一个内核代码和数据段，但它们通过各自的页表映射到物理内存的不同区域（尽管内核代码/数据本身在物理内存中是共享的），并且每个进程有自己的内核栈。

```
+-----------------------+   <-- 虚拟地址上限 (例如 0xFFFFFFFF 或 0xFFFFFFFFFFFFFFFF)
| 进程虚拟地址空间      |
+-----------------------+
| 内核空间              |   <-- 通常固定高位地址区域
|   内核代码及数据      |
|   内核栈              |   <-- 每个进程/线程有自己的内核栈
|   ...                 |
+-----------------------+
| 用户空间              |   <-- 通常从低位地址开始
|   用户栈 (Stack)      |   <-- 动态增长/收缩，通常向低地址增长
|   (栈与堆之间可能保留空间) |
|   用户堆 (Heap)       |   <-- 动态增长/收缩，通常向高地址增长
|   静态数据段 (.data, .bss)|
|   程序代码段 (.text)    |
|   ...                 |
+-----------------------+   <-- 虚拟地址下限 (通常是 0x00000000)
```

### 进程控制块 (PCB)

**如何表示进程**：操作系统为了管理每个进程，会为每个进程维护一个数据结构，称为**进程控制块 (PCB)** 或 **任务控制块 (TCB - Task Control Block)**。

- 进程控制块存储在**内核态**内存中，**不可被用户态程序直接访问或修改**，确保了操作系统的安全性和进程的隔离性。
- PCB 包含了操作系统管理和调度进程所需的所有信息，至少应保存以下信息：
    - **进程标识符 (PID)**：唯一标识一个进程。
    - **进程状态**：如运行 (Running)、就绪 (Ready)、等待 (Waiting/Blocked)、终止 (Terminated) 等。
    - **程序计数器 (PC)**：指向下一条将要执行的指令的地址。
    - **寄存器集合**：包括通用寄存器、栈指针 (SP)、程序状态字 (PSW) 等，保存了进程在 CPU 上的执行上下文。
    - **调度信息**：进程优先级、调度队列指针等。
    - **内存管理信息**：指向该进程页表的指针（例如 x86 上的 CR3 寄存器值或 ARM 上的 TTBR 寄存器值）、段表信息等，用于地址翻译。
    - **文件管理信息**：进程打开的文件列表（文件描述符表）、当前工作目录等。
    - **信号处理信息**：进程的信号掩码、信号处理函数地址等。
    - **I/O 状态信息**：进程请求的 I/O 设备、分配的缓冲区等。

```
+-----------------------------+
| Process Control Block (PCB) |
+-----------------------------+
| Process ID (PID)            |
| 进程状态 (运行、就绪、等待等) |
| 程序计数器 (PC)             |
| 寄存器集合 (包括 SP)        |
| 调度信息 (优先级等)         |
| 内存管理信息 (页表指针等)     |
| 文件描述符表                |
| 信号处理信息                |
| I/O 状态信息                |
+-----------------------------+
```

### 进程的创建

进程的创建通常涉及资源分配、PCB 初始化等步骤。

- **`fork()` 系统调用**：创建一个**新的进程**，它是父进程的一个**几乎完全相同**的副本。子进程拥有独立的内存空间、文件描述符副本等。现代操作系统通常采用**写时复制 (Copy-on-Write, CoW)** 技术来优化 `fork()` 的性能，只有当父进程或子进程尝试修改共享的页面时，才会真正复制该页面。
- **`exec()` 系统调用**：在**当前进程**的地址空间中**加载并执行一个新的程序**。它会用新的程序代码和数据替换当前进程的用户空间内容，但进程的 PID 通常不变，文件描述符等也默认保留。
- **`fork()` + `exec()`**：是 Unix/Linux 系统中创建新进程并运行一个新程序的标准组合方式。`fork()` 创建子进程，然后子进程调用 `exec()` 加载并运行目标程序。
- **`posix_spawn()`**：是 POSIX 标准中提供的一种替代 `fork()` 和 `exec()` 组合创建进程的方式。它通常能更高效地创建新进程，尤其是在需要指定各种属性时，因为它避免了不必要的内存复制（如 `fork()` 中的全部复制，即使使用了 CoW ）。但它在复杂场景下的灵活性可能不如 `fork()`。
- **其他创建方式**：如 Windows API 中的 `CreateProcess`。

**`fork()` 的缺点** (在没有 CoW 或大量修改页面的场景下)：

- 完全复制进程地址空间（即使是虚拟地址空间的映射）和 PCB 等资源开销较大。
- 性能开销可能较高，尤其是在创建大量进程时。

关于“现在有些操作系统进程不只共享页，还可以**共享一部分的页表**”，这确实是可能的优化手段，例如在 CoW 机制下，父子进程 initially 共享同一个页表（或者页表的上层结构），只有在发生写操作时才复制和修改相关的页表项。

## 线程 (Thread)

### 为什么需要线程？

进程作为资源分配的基本单位，其创建、撤销和切换的开销都比较大。在一个进程内部，如果需要同时执行多个任务（例如，一个图形界面程序需要同时响应用户输入、更新界面、处理数据），如果使用多个进程，进程间通信和协调会比较复杂。线程应运而生，作为程序执行的**基本单位**，**共享**进程的资源，从而降低开销并提高并发性。

### 线程的定义与优势

- 一个进程可以包含**多个线程**。
- 同一个进程中的所有线程**共享**进程的**虚拟地址空间**、文件描述符表、信号处理等大部分资源。
- 每个线程拥有自己的**独立执行状态**，包括程序计数器 (PC)、栈指针 (SP)、寄存器集合，以及独立的栈（用户栈和可能的内核栈）。

**优势**：

- **开销小**：线程的创建、撤销和切换只需要保存和恢复少量线程私有的状态（主要是寄存器和栈），远小于进程的开销。
- **提高并发度**：在一个多核处理器上，同一进程内的多个线程可以并行执行，提高程序的吞吐量。在单核处理器上，线程间的快速切换可以提供更好的响应性和伪并行。
- **方便通信**：同一进程内的线程可以直接访问共享的内存数据，实现高效的通信，避免了复杂的进程间通信 (IPC) 机制。

### 线程模型

描述了用户级线程库如何与操作系统内核提供的内核级线程进行映射。

- **一对一模型 (One-to-One)**：一个用户态线程对应一个内核态线程。
    - 优点：能够充分利用多核处理器并行性，一个线程阻塞不会影响其他线程。
    - 缺点：每个用户线程都需要一个内核线程，创建和管理开销相对较大，受限于操作系统支持的内核线程数量。
- **多对一模型 (Many-to-One)**：多个用户态线程映射到一个内核态线程。
    - 优点：线程管理在用户空间进行，开销小，创建线程快。
    - 缺点：一个用户线程阻塞会导致整个进程阻塞；无法在多核处理器上实现真正的并行性。现在较少使用。
- **多对多模型 (Many-to-Many)**：N 个用户态线程映射到 M 个内核态线程 (N >= M)。
    - 优点：结合了前两者的优点，既能利用多核并行性，又能避免过多内核线程的开销，且一个用户线程阻塞通常不会阻塞整个进程。
    - 缺点：模型实现和管理复杂，需要在用户空间和内核空间之间进行协调。

### TCB

每个线程都有一个**线程控制块 (TCB - Thread Control Block)**。它存储了线程的私有信息。

- 对于**内核级线程**（或一对一模型中的用户线程），TCB 通常存储在**内核态**，由操作系统管理。
- 对于**用户级线程**（如多对一模型中的线程），TCB 存储在**用户态**的线程库中管理。
- TCB 主要包含线程私有的执行上下文：
    - **程序计数器 (PC)**
    - **栈指针 (SP)**
    - **寄存器集合**
    - **线程状态** (运行、就绪、等待等)
    - **指向所属进程 PCB 的指针**
    - **栈信息** (用户栈的起始地址、大小等)
    - **线程本地存储 (Thread-Local Storage, TLS)**：用于存储线程特有的数据，这些数据在同一进程的不同线程中是独立的。TLS 的实现通常依赖于特定的寄存器或内存区域加上偏移量来访问。
- "用下划线定义的变量通常是每个线程私有的" 这是一种编程语言或库的**约定**，不是操作系统层面的概念。线程私有的数据在操作系统层面主要通过**线程栈**和**线程本地存储 (TLS)** 机制来保证隔离性。
- "私有变量的存储方式通常是**基地址 + 偏移量**" 这更像是描述如何访问 TLS 中的数据，或者如何计算局部变量在栈上的地址。线程栈本身是线程私有的内存区域，局部变量就直接在栈上分配。

## 上下文切换 (Context Switching)

**上下文切换**：是操作系统将 CPU 的控制权从当前正在执行的进程或线程转移到另一个就绪状态的进程或线程的过程。

### 上下文切换发生在哪里？

- **内核级上下文切换**：发生在**内核态**。当从一个内核线程切换到另一个内核线程，或者从一个进程切换到另一个进程时，都涉及内核态的操作。
- **用户级上下文切换**：在使用用户级线程模型（如多对一）时，线程库可以在用户态完成线程间的切换，无需内核介入。但这不涉及 CPU 核心的切换（仍然在同一个内核线程上运行），且如果其中一个用户线程执行阻塞系统调用，整个进程会阻塞。我们这里主要讨论**内核级上下文切换**。

进入内核态的方式：

- **系统调用 (System Call)**：用户程序主动请求操作系统服务。
- **中断 (Interrupt)**：
    - **硬件中断**：外部设备（如 I/O 完成、定时器）发出的信号。
    - **软件中断 / 陷阱 (Trap)**：由 CPU 执行指令引起（如除零错误、访问非法内存、或者某些系统调用就是通过 `trap` 指令实现）。

### 需要保存哪些上下文信息？

进行上下文切换时，需要保存当前执行实体的完整执行状态信息，以便下次重新调度它时能够从中断点恢复执行。保存的信息通常包括：

- **CPU 寄存器**：包括通用寄存器、指令寄存器 (PC)、栈指针 (SP)、程序状态字 (PSW) 等。这些是 CPU 硬件状态的直接反映。
- **内存管理信息**：如页表基址寄存器（用于虚拟地址到物理地址的翻译），因为不同进程有不同的虚拟地址空间。
- **其他状态信息**：如文件描述符表（尽管进程间共享，但在切换时可能需要更新内核中的当前进程文件信息）、信号掩码等（这些通常保存在 PCB/TCB 中）。

**为什么进程/线程上下文需要保存寄存器信息，而不用保存内存呢？**

- **寄存器**：CPU 只有一套寄存器。当切换到另一个执行实体时，新的实体需要使用这套寄存器。如果不保存当前实体的寄存器值，这些值就会丢失或被覆盖。
- **内存**：进程或线程的内存内容（代码、数据、堆、栈）在切换发生时并**不会消失**。它们仍然驻留在物理内存中（或者被换出到磁盘），并且通过该进程/线程的页表进行管理。下次切换回来时，通过加载其页表基址，就可以重新访问其内存空间。

### 内核栈的作用

- **为什么需要内核栈？**
    - 当进程或线程通过系统调用或中断进入内核态执行时，它需要在内核中执行代码（如系统调用处理函数、中断服务程序）。
    - 在内核态执行时，同样需要调用函数、传递参数、保存局部变量，这就需要一个栈。
    - 由于用户态和内核态的内存空间是隔离的，**在内核中不能直接使用用户态的栈**（为了安全性和隔离性）。
    - 因此，每个进程或内核线程都需要有一个**独立的内核栈**用于在内核态执行时的堆栈操作。
- 用户栈用于用户态函数调用，内核栈用于内核态函数调用。

### 切换过程 (从用户态进入内核态 及 全局上下文切换)

1. 从用户态进入内核态：
	
	当发生系统调用或中断时：
	
	a. 用户态程序执行陷入指令 (如 syscall 或 trap) 或被硬件中断。
	
	b. CPU 硬件自动完成一些初始的上下文保存工作，通常是将当前用户态的关键寄存器（如 PC、SP、程序状态字）自动压入当前进程的内核栈中。
	
	c. CPU 切换到内核态（改变 CPU 模式位），并跳转到操作系统预设的、处理该系统调用或中断的入口点。
	
	d. 操作系统内核接管控制，进一步保存当前用户态（或内核态）的更多寄存器状态到内核栈或 PCB/TCB 中。
	
	e. 内核执行相应的处理程序（系统调用处理函数或中断服务程序）。

2. 全局上下文切换 (例如，从线程A 切换到线程B)：

	**上下文切换通常发生在内核态，由操作系统的调度器触发。**
	
	a. 保存当前线程/进程的上下文：操作系统将当前正在执行的线程/进程的全部上下文信息（包括 CPU 寄存器、PC、SP、以及在进入内核时保存在内核栈中的信息）保存到其对应的 TCB/PCB 中。
	
	b. 加载下一个线程/进程的上下文：调度器选择下一个要执行的线程/进程。操作系统从该线程/进程的 TCB/PCB 中加载其保存的上下文信息到 CPU 寄存器中。
	
	c. 切换虚拟地址空间 (仅当切换到不同进程时需要)：如果切换的是不同的进程，还需要修改 CPU 的页表基址寄存器（如 x86 的 CR3 或 ARM 的 TTBRx），指向新进程的页表。
	
	d. 跳转到新的执行点：CPU 根据新加载的 PC 值开始执行下一条指令，SP 指向新的栈顶。如果切换发生在内核态，可能会直接在内核态继续执行（例如，从一个阻塞的内核线程切换到另一个就绪的内核线程）。如果切换发生在用户态和内核态的边界（例如，从一个进程的用户态通过中断进入内核，然后在内核中切换到另一个进程的用户态），则会通过特定的指令 (如 iret 或 eret) 从内核返回到新的进程的用户态。

```
+-----------------+           +-----------------+
|  Thread A       |           |  Thread B       |
|  (用户态执行)    |           |  (用户态执行)    |
+-----------------+           +-----------------+
         | (系统调用/中断)              ^ (从内核返回)
         v                             |
+-----------------+           +-----------------+
|  内核态入口     |           |  内核态处理     |
| (CPU自动保存状态) |           | (准备返回用户态) |
+-----------------+           +-----------------+
         | (OS进一步保存状态到TCB A)     ^ (OS加载状态从TCB B)
         v                             |
+------------------------------------------+
|         调度器选择 Thread B              |
+------------------------------------------+
         | (保存/加载TCB/PCB)
         v
+------------------------------------------+
|         虚拟地址空间切换 (如需)          |
|         TLB 刷新 (如需)                  |
+------------------------------------------+
         | (加载 Thread B 的上下文)
         v
+-----------------+           +-----------------+
|  内核态退出     |           |  Thread B       |
| (通过iret/eret) | ---------> |  (用户态恢复执行)|
+-----------------+           +-----------------+

注: 上图简化了流程，实际切换可能更复杂，且并非总是在用户态和内核态边界发生。
一次完整的进程/线程切换可能完全在内核态发生。
```

### 虚拟地址空间的切换与 TLB 刷新

- **虚拟地址空间的切换**：当操作系统在不同进程之间切换时，必须切换当前的虚拟地址空间。这是通过修改 CPU 的页表基址寄存器来完成的，使其指向目标进程的页表。
- **TLB (Translation Lookaside Buffer) 刷新**：TLB 是 CPU 中的一个缓存，用于存储最近使用的虚拟地址到物理地址的翻译映射。当页表基址寄存器被修改（即切换了虚拟地址空间）后，TLB 中缓存的旧的虚拟地址映射关系就不再有效，必须将其全部或部分清除 (flush)，否则会导致错误的地址翻译。刷新 TLB 是一项开销较高的操作，因为它可能导致后续的内存访问都需要进行完整的页表遍历，直到 TLB 重新填充。

```
+-------------------------+
| TLB (地址翻译缓存)      |
+-------------------------+
| 旧的虚拟地址 -> 物理地址映射|
| (属于进程 A)             |
+-------------------------+
          | (进程 A -> 进程 B 切换)
          | 虚拟地址空间切换 (修改页表基址寄存器)
          v
+-------------------------+
| TLB 失效，需要刷新/无效化 |
| (旧映射不再有效)         |
+-------------------------+
          | (TLB 刷新完成)
          v
+-------------------------+
| TLB 空或开始填充新的映射  |
| (属于进程 B)             |
+-------------------------+
```

---
> - **进程**是资源分配的单位，拥有独立的虚拟地址空间和资源，通过 PCB 管理。
> - **线程**是调度的基本单位，共享进程的大部分资源，拥有独立的执行状态（PC, SP, 寄存器, 栈），通过 TCB 管理。线程的开销小于进程。
> - **上下文切换**是操作系统切换执行流的过程，需要保存当前执行实体的状态（主要在 PCB/TCB 中，寄存器临时保存在内核栈或 TCB 中），加载下一个执行实体的状态。进程切换比线程切换开销更大，因为它通常涉及虚拟地址空间的切换和 TLB 刷新。内核栈在进入内核态执行时起着至关重要的作用。
