
> 当物理内存不足时，操作系统需要将部分不常用的内存页**换出 (swap out)**到磁盘空间。这些被换出的页面通常存储在磁盘的**交换区 (swap space)**中（如果是非文件页的数据页）。当程序再次访问这些页面时，会触发**缺页异常 (Page Fault)**，操作系统需要将对应的页面**换入 (swap in)**物理内存。
> 
> **换页策略 (Page Replacement Policy)** 决定了在发生缺页且物理内存已满时，应该选择哪个物理内存中的页面被换出，以便为新的页面腾出空间。好的策略可以最小化缺页率。

### 理想的换页策略 (OPT - Optimal Page Replacement Policy)

**思想**：在选择被换出的页面时，优先选择在**未来最长时间内不会再被访问**的页面。如果存在多个这样的页面，可以选择其中任意一个。

**特点**：

- 这是一种**理想化的策略**。因为它需要预知未来页面的访问顺序，而这是不可能在实际系统中实现的。
- 尽管不可实现，但它可以作为评价其他换页策略性能的**参照标准**或**最优理论上限**。

**示例**（假设物理内存可存放 3 个物理页框 (frame)，初始为空，访问页面序列：3, 2, 3, 1, 4, 3, 5, 4, 2, 3, 4, 3）

我们将物理内存中的页框内容表示为 `[frame0, frame1, frame2]`。

| **物理页面访问顺序** | **3**   | **2**   | **3**   | **1**   | **4**   | **3**   | **5**   | **4**   | **2**   | **3**   | **4**   | **3**   |
| ------------ | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- |
| 物理内存内容       | [3,-,-] | [3,2,-] | [3,2,-] | [3,1,-] | [3,4,-] | [3,4,-] | [3,5,-] | [3,4,-] | [3,2,-] | [3,2,-] | [3,4,-] | [3,4,-] |
| 缺页异常 (PF)    | 是       | 是       | 否       | 是       | 是       | 否       | 是       | 是       | 是       | 否       | 是       | 否       |
| **总缺页次数**    | 1       | 2       | 2       | 3       | 4       | 4       | 5       | 6       | 7       | 7       | 8       | 8       |

**总缺页异常次数 (使用 3 个物理页框)：8 次**。

### 先进先出策略 (FIFO - First In, First Out)

**思想**：操作系统维护一个队列，记录物理页框中页面的载入时间顺序。**最先被加载进物理内存的页面，优先被换出**。新载入的页面放在队尾。

**特点**：

- 实现非常简单。
- 它没有考虑页面的实际使用情况（访问频率或最近访问时间），可能会换出经常使用的页面，导致较高缺页率。

**示例**（假设物理内存可存放 3 个物理页框，初始为空，访问页面序列：3, 2, 3, 1, 4, 3, 5, 4, 2, 3, 4, 3）

队列表示物理内存中的页面及其载入顺序 (左边为最老，右边为最新)。

| **物理页面访问顺序** | **3**   | **2**   | **3**   | **1**   | **4**   | **3**   | **5**   | **4**   | **2**   | **3**   | **4**   | **3**   |
| ------------ | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- |
| 物理内存内容       | [3,-,-] | [3,2,-] | [3,2,-] | [2,1,3] | [1,4,3] | [4,3,1] | [3,5,4] | [5,4,3] | [4,2,5] | [2,3,4] | [3,4,2] | [3,4,2] |
| 队列 (先进->后出)  | [3]     | [3,2]   | [3,2]   | [2,1,3] | [1,4,3] | [4,3,1] | [3,5,4] | [5,4,3] | [4,2,5] | [2,3,4] | [3,4,2] | [3,4,2] |
| 替换的页面        | -       | -       | -       | 3       | 2       | 1       | 4       | 3       | 5       | 4       | 2       | -       |
| 缺页异常 (PF)    | 是       | 是       | 否       | 是       | 是       | 是       | 是       | 是       | 是       | 是       | 是       | 否       |
| **总缺页次数**    | 1       | 2       | 2       | 3       | 4       | 5       | 6       | 7       | 8       | 9       | 10      | 10      |

**总缺页异常次数 (使用 3 个物理页框)：10 次**。

#### **Belady's Anomaly (贝拉迪现象)**：

对于 FIFO 策略，**增加分配给进程的物理页框数量，反而可能导致缺页异常次数增加**。这是 FIFO 的一个重要缺点，表明它有时违反了直观的“更多内存更好”的原则。其他一些策略（如 LRU, OPT）则不会出现此现象。

**示例**：访问顺序: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5

- **3 个物理页框**：9 次 page faults
- **4 个物理页框**：10 次 page faults (缺页次数增加)

### 第二次机会策略 (Second Chance / SC)

**思想**：FIFO 策略的一种改进版本，试图利用页面的访问信息。它使用一个**访问位 (Reference Bit, R)**，通常在页表项 (PTE) 中由硬件设置。

**实现**：

1. 维护一个物理页框的队列（或循环列表）。
2. 每个页面有一个访问位 (R)，初值为 0。当页面被访问（读或写）时，硬件将对应的页表项中的 R 位设为 1。
3. 当需要换页时，检查队列头部（最老）的页面：
    - 如果该页面的 **R 位为 0**，则该页面最近没有被访问，**直接换出**该页面。
    - 如果该页面的 **R 位为 1**，则表明该页面近期被访问过。操作系统将该页面的 **R 位清零 (设为 0)**，并将该页面移到队列尾部，给它“第二次机会”，然后继续检查新的队列头部页面。
    - 这个过程可以用一个循环指针表示，类似于时钟表面，因此也常被称为**时钟算法 (Clock Algorithm)**。

**特点**：

- 实现比 LRU 简单，开销小。
- 通过利用访问位，在一定程度上近似了 LRU 策略，倾向于保留近期被访问过的页面。
- 消除了 Belady's Anomaly。

**示例**（假设物理内存可存放 3 个物理页框，初始为空，访问页面序列：3, 2, 3, 1, 4, 3, 5, 4, 2, 3, 4, 3）

我们使用表格展示每一步操作后，物理页框中的内容（页号和访问位 R），以及循环检查的指针位置。指针指向下一个将被检查的页框。

| **访问页面** | **动作**   | **物理页框 0 (页号, R)** | **物理页框 1 (页号, R)** | **物理页框 2 (页号, R)** | **指针位置** | **缺页次数 (PF)** | **备注说明**                                                                                                                |
| -------- | -------- | ------------------ | ------------------ | ------------------ | -------- | ------------- | ----------------------------------------------------------------------------------------------------------------------- |
| Initial  | -        | (-,0)              | (-,0)              | (-,0)              | 0        | 0             | 初始状态                                                                                                                    |
| 3        | PF, Load | (3,1)              | (-,0)              | (-,0)              | 1        | 1             | 载入 3                                                                                                                    |
| 2        | PF, Load | (3,1)              | (2,1)              | (-,0)              | 2        | 2             | 载入 2                                                                                                                    |
| 3        | Hit      | (3,1)              | (2,1)              | (-,0)              | 2        | 2             | 访问 3 (在 F0)，R(3) 设为 1 (已是)                                                                                              |
| 1        | PF, Load | (1,1)              | (2,0)              | (-,0)              | 1        | 3             | 满。查 F2 空 -> 0. 查 F0(3,1): R=1->0, Ptr->1. 查 F1(2,1): R=1->0, Ptr->2. 查 F2 空 -> 0. 查 F0(3,0): R=0. 替换 F0(3) 载入 1. Ptr->1 |
| 4        | PF, Load | (1,1)              | (4,1)              | (-,0)              | 2        | 4             | 满。查 F1(2,0): R=0. 替换 F1(2) 载入 4. Ptr->2.                                                                                |
| 3        | PF, Load | (3,1)              | (4,0)              | (-,0)              | 1        | 5             | 满。查 F2 空 -> 0. 查 F0(1,1): R=1->0, Ptr->1. 查 F1(4,1): R=1->0, Ptr->2. 查 F2 空 -> 0. 查 F0(1,0): R=0. 替换 F0(1) 载入 3. Ptr->1 |
| 5        | PF, Load | (3,1)              | (5,1)              | (-,0)              | 2        | 6             | 满。查 F1(4,0): R=0. 替换 F1(4) 载入 5. Ptr->2.                                                                                |
| 4        | Hit      | (3,1)              | (5,1)              | (-,0)              | 2        | 6             | 访问 4 (在 F1)，R(4) 设为 1                                                                                                   |
| 2        | PF, Load | (2,1)              | (5,0)              | (-,0)              | 1        | 7             | 满。查 F2 空 -> 0. 查 F0(3,1): R=1->0, Ptr->1. 查 F1(5,1): R=1->0, Ptr->2. 查 F2 空 -> 0. 查 F0(3,0): R=0. 替换 F0(3) 载入 2. Ptr->1 |
| 3        | PF, Load | (2,1)              | (3,1)              | (-,0)              | 2        | 8             | 满。查 F1(5,0): R=0. 替换 F1(5) 载入 3. Ptr->2.                                                                                |
| 4        | PF, Load | (4,1)              | (3,0)              | (-,0)              | 1        | 9             | 满。查 F2 空 -> 0. 查 F0(2,1): R=1->0, Ptr->1. 查 F1(3,1): R=1->0, Ptr->2. 查 F2 空 -> 0. 查 F0(2,0): R=0. 替换 F0(2) 载入 4. Ptr->1 |
| 3        | Hit      | (4,1)              | (3,1)              | (-,0)              | 2        | 9             | 访问 3 (在 F1)，R(3) 设为 1                                                                                                   |

**总缺页异常次数 (使用 3 个物理页框)：9 次**。

### 最近最少使用策略 (LRU - Least Recently Used)

**思想**：选择**近期最少使用的页面**进行换出。这基于局部性原理，认为过去最少使用的页面，在未来也最可能不会被使用。

**特点**：

- 很好地体现了**局部性原理**，通常能获得比 FIFO 和 Second Chance 更低的缺页率（在很多场景下接近 OPT）。
- **难以精确实现**：需要跟踪每个页面的精确访问时间顺序，实现开销较大（软件实现复杂，硬件实现成本高）。
- 对于特定的访问序列（如循环访问一个大于物理内存大小的工作集），效果可能非常差。

**示例**（假设物理内存可存放 3 个物理页框，初始为空，访问页面序列：3, 2, 3, 1, 4, 3, 5, 4, 2, 3, 4, 3）

LRU 列表表示物理内存中的页面，头部为最近最少使用 (LRU)，尾部为最近最多使用 (MRU)。

| **物理页面访问顺序**      | **3**   | **2**   | **3**   | **1**   | **4**   | **3**   | **5**   | **4**   | **2**   | **3**   | **4**   | **3**   |
| ----------------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- |
| 物理内存内容            | [3,-,-] | [3,2,-] | [3,2,-] | [3,1,-] | [1,4,-] | [4,3,-] | [3,5,-] | [5,4,-] | [4,2,-] | [2,3,-] | [3,4,-] | [3,4,-] |
| LRU 列表 (LRU->MRU) | [3]     | [3,2]   | [2,3]   | [3,1]   | [1,4]   | [4,3]   | [3,5]   | [5,4]   | [4,2]   | [2,3]   | [3,4]   | [4,3]   |
| 替换的页面             | -       | -       | -       | 2       | 3       | 1       | 4       | 3       | 5       | 4       | 2       | -       |
| 缺页异常 (PF)         | 是       | 是       | 否       | 是       | 是       | 是       | 是       | 是       | 是       | 是       | 是       | 否       |
| **总缺页次数**         | 1       | 2       | 2       | 3       | 4       | 5       | 6       | 7       | 8       | 9       | 10      | 10      |

**总缺页异常次数 (使用 3 个物理页框)：10 次**。

### 时钟算法策略 (Clock Algorithm)

时钟算法是 Second Chance 策略的一种具体实现形式，通常用于近似 LRU。其思想和实现见上面的 Second Chance 策略描述。

**实现细节补充**：

- **访问位 (R) 和修改位 (Dirty Bit, D)**：操作系统在页表项 (PTE) 中利用硬件提供的 R 位和 D 位。R 位由硬件在页面被访问时设置，D 位在页面被修改时设置。
- **驱逐页面**：当一个物理页框被选中换出时：
    - 如果 D 位为 1（脏页），必须写回磁盘。
    - 如果 D 位为 0（干净页），可以直接丢弃。
    - 必须找到并**清空所有映射到该物理页框的页表项**（通过反向映射），并使 TLB 中对应的条目失效。
- **Clock 的变种 (NRU)**：除了 R 位，还可以利用 D 位。例如，优先替换 (R=0, D=0) 的页面，其次是 (R=0, D=1)，然后是 (R=1, D=0)，最后是 (R=1, D=1)。

### 页替换策略小结

**常见的替换策略**：

- **静态策略**：FIFO, Second Chance (Clock), LRU, NRU (Clock 变种), Random (随机替换)。
- **动态策略**：根据进程的运行行为动态调整分配的内存页框数量，例如 **工作集 (Working Set)** 模型和 **缺页频率 (Page Fault Frequency, PFF)** 控制。

**替换策略评价标准**：

- **缺页发生的概率**：通常通过仿真使用特定访问序列测试，并与 OPT 策略的结果进行比较。
- **策略本身的性能开销**：实现复杂度、CPU 开销（维护数据结构、扫描等）、内存开销（额外的数据结构）。
- **是否会发生 Belady's Anomaly**。

**如何高效记录物理页的使用情况？** 利用硬件提供的页表项中的 Access (R) 位和 Dirty (D) 位是关键。这些位由硬件自动设置，操作系统只需定期检查和清除。

## Thrashing Problem (颠簸问题)

### 直接原因

- **进程的内存需求总和大于物理内存容量**：系统中运行的进程需要比当前可用物理内存更多的页面才能高效执行。
- **过于频繁的缺页异常**：当一个进程的**工作集**（当前正在使用的页面的集合）无法完全载入物理内存时，进程就会频繁地发生缺页，每次访问一个新页面都需要从磁盘换入，同时又不得不换出一个可能很快又要用到的页面。
- **大部分 CPU 时间被用来处理缺页异常**：操作系统忙于进行磁盘 I/O（页面换入换出）以及处理缺页中断，而真正用于执行应用程序指令的时间很少。
- **CPU 利用率急剧下降**：因为大部分时间都在等待慢速的磁盘 I/O。

### 调度器造成问题加剧

颠簸问题常常形成一个恶性循环：

1. **CPU 利用率下降**：由于进程频繁等待页面I/O，CPU 大部分时间处于空闲状态。
2. **调度器误判**：操作系统调度器通常会尝试提高 CPU 利用率，当它发现 CPU 空闲时，会认为系统有空闲资源，于是**载入更多的进程**到内存中准备运行。
3. **内存竞争加剧**：新载入的进程进一步瓜分有限的物理内存资源。
4. **每个进程获得的物理页框更少**：分配给每个进程的内存可能不足以容纳其工作集。
5. **触发更多的缺页异常**：所有进程的缺页率都可能增加。
6. **进一步降低 CPU 利用率**：系统花更多时间处理 I/O。
7. **恶性循环**：循环回到第 2 步，调度器可能继续加载更多进程，使问题更严重。

最终结果是系统吞吐量急剧下降，响应时间变长，系统似乎“挂起”了，但 CPU 仍然在忙碌地处理缺页。

**解决颠簸的手段**：

- **提供更多物理内存**。
- **减少系统中同时运行的进程数量**（通过限制多道程序的程度）。
- **采用基于工作集或缺页频率的动态内存分配策略**，确保每个运行的进程都能获得足够多的页框来容纳其工作集。
