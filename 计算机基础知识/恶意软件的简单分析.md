
- 本文档主要侧重于分析针对 Windows 操作系统的恶意软件。
## 恶意软件的简单分类

- `Viruses`这些恶意软件旨在渗透并在主机文件中繁殖，从一个系统迁移到另一个系统。它们会附着在正常程序上，并在受感染文件被触发时立即采取行动。它们从篡改数据到扰乱系统功能，甚至通过网络传播，造成大范围破坏。
    
- `Worms`：蠕虫是一种自主恶意软件，无需人工干预即可在网络中繁殖。它们利用网络漏洞，未经许可即可入侵系统。一旦进入系统，它们既可以传播破坏性的有效载荷，也可以继续繁殖到其他易受攻击的设备。蠕虫可以快速发起不断升级的感染，造成巨大的破坏，甚至可能引发拒绝服务攻击。
    
- `Trojans`：也称为特洛伊木马，它们伪装成正版软件，诱骗用户运行。进入系统后，它们会创建后门，使攻击者能够远程获取未经授权的控制权。特洛伊木马可以被用作武器，窃取敏感数据（例如密码或财务信息），并在受感染的系统上策划其他有害活动。
    
- `Ransomware`：这种恶意恶意软件会加密目标系统上的文件，使其无法访问。攻击者随后索要赎金以换取解密密钥，实际上是劫持受害者的​​数据以勒索赎金。
    
- `Spyware`：此类恶意软件会在未经用户同意的情况下秘密收集敏感数据和用户活动。它可以追踪用户的在线浏览习惯、记录键盘输入并获取登录凭据，对隐私和安全构成严重威胁。
    
- `Adware`：它会在受感染的系统上显示未经授权的侵入性广告，通常会导致用户体验不佳。广告软件还可能跟踪用户行为并收集数据。
    
- `Backdoors/RATs (Remote Access Trojans)`后门和远程访问木马 (RAT) 旨在从远程位置对受感染系统进行未经授权的访问和控制。攻击者可以利用它们来保持长期控制、提取数据或发起更多攻击。
    
- `Droppers`：这类恶意软件用于将额外的恶意负载传输并安装到受感染的系统上。它们充当其他恶意软件的通道，确保更复杂的威胁得以隐蔽地安装和执行。
    
- `Information Stealers`：这些恶意软件专门用于锁定和提取敏感数据（例如登录凭证、个人信息或知识产权），用于恶意目的。这包括身份盗窃或在暗网上出售数据。

## 常用工具

#### 磁盘取证工具

- **FTK Imager**：由AccessData（现已被Exterro收购）开发，FTK Imager是网络安全领域最广泛使用的磁盘成像工具之一。它允许我们创建计算机磁盘的完美副本（或镜像），以便分析，并能保持证据的完整性。它还允许我们在不更改数据的情况下查看和分析数据存储设备的内容。
    
- **OSFClone**：这是一个免费的开源工具，专为创建和克隆取证磁盘镜像而设计。它使用简单，支持多种文件系统。
    
- **DD和DCFLDD**：这两个命令行工具可在基于Unix的系统（包括Linux和MacOS）上使用。DD是一个通用工具，默认包含在大多数Unix系统中，而DCFLDD是DD的增强版本，具有专门用于取证的功能，如哈希值计算。
    

#### 内存采集工具

- **DumpIt**：这是一个简单的工具，用于生成Windows和Linux机器的物理内存转储。在Windows上，它将32位和64位系统物理内存合并成一个单一的输出文件，使用非常简便。
    
- **MemDump**：MemDump是一个免费的简洁命令行工具，用于捕获系统RAM的内容。它在取证调查或分析系统中的恶意活动时非常有用。其简单易用的特点使其成为内存采集的流行选择。
    
- **Belkasoft RAM Capturer**：这是另一款功能强大的内存采集工具，由Belkasoft免费提供。它能够捕获正在运行的Windows计算机的RAM，即使存在活跃的反调试或反转储保护，也能成功提取数据。这使其在现场取证调查中非常有效，能够提取尽可能多的数据。
    
- **Magnet RAM Capture**：由Magnet Forensics开发，这款工具提供了一种简单而免费的方式来捕获系统的易失性内存。
    
- **LiME (Linux Memory Extractor)**：LiME是一个加载内核模块（LKM），用于采集易失性内存。LiME的独特之处在于它被设计成对目标系统透明，能够绕过许多常见的反取证措施。
    
#### 其他

- **KAPE (Kroll Artifact Parser and Extractor)**：KAPE是一个快速收集和解析数字取证证据的程序。它专注于目标化的采集，减少收集数据的数量和分析所需的时间。
    
- **Velociraptor**：Velociraptor是一个多功能工具，专为主机基础的事件响应和数字取证设计。它允许快速、目标化地收集多台机器的数据。Velociraptor使用Velocidex查询语言（VQL）。
## 内核模式与用户模式

Windows作系统以两种主要模式运行：

- `User Mode`：此模式是大多数应用程序和用户进程运行的地方。用户模式下的应用程序对系统资源的访问受到限制，并且必须通过应用程序编程接口 （API） 与作系统交互。这些进程彼此隔离，无法直接访问硬件或关键系统功能。但是，在此模式下，恶意软件仍然可以纵文件、注册表设置、网络连接和其他用户可访问的资源，并且它可能会尝试提升权限以获得对系统的更多控制。
    
- `Kernel Mode`：相比之下，内核模式是运行 Windows 内核的高特权模式。内核可以不受限制地访问系统资源、硬件和关键功能。它提供核心作系统服务，管理系统资源，并实施安全性和稳定性。设备驱动程序（便于与硬件设备通信）也在内核模式下运行。如果恶意软件在内核模式下运行，它将获得更高的控制权，并可以纵系统行为、隐藏其存在、拦截系统调用和篡改安全机制。

![[Pasted image 20250506031636.png]]

### 用户模式组件  
用户模式组件是操作系统中不直接访问硬件或内核数据结构的部分。它们通过API和系统调用与系统资源进行交互。

- **系统支持进程**：这些是提供关键功能和服务的基本组件，如登录进程（winlogon.exe）、会话管理器（smss.exe）和服务控制管理器（services.exe）。它们不是Windows服务，但对于系统的正常运行至关重要。
    
- **服务进程**：这些进程承载Windows服务，如Windows更新服务、任务调度程序和打印后台处理程序服务。它们通常在后台运行，根据配置和参数执行任务。
    
- **用户应用程序**：这些是由用户程序创建的进程，包括32位和64位应用程序。它们通过Windows提供的API与操作系统交互。这些API调用会被重定向到NTDLL.DLL，触发从用户模式到内核模式的过渡，在内核模式下执行系统调用。然后，结果返回给用户模式应用程序，并发生从内核模式到用户模式的过渡。
    
- **环境子系统**：这些组件负责为特定类型的应用程序或进程提供执行环境。它们包括Win32子系统、POSIX和OS/2。
    
- **子系统DLL**：这些动态链接库将文档化的函数转换为适当的内部本地系统调用，主要由NTDLL.DLL实现。例如，kernelbase.dll、user32.dll、wininet.dll和advapi32.dll。
    

### 内核模式组件  

内核模式组件是操作系统中可以直接访问硬件和内核数据结构的部分。它们包括：

- **执行管理器**：这是内核模式中的上层，通过NTDLL.DLL中的函数访问。它包括I/O管理器、对象管理器、安全参考监视器、进程管理器等组件，负责管理操作系统的核心方面，如I/O操作、对象管理、安全性和进程。它首先运行一些检查，然后将调用传递给内核，或调用适当的设备驱动程序来执行请求的操作。
    
- **内核**：该组件管理系统资源，提供低级服务，如线程调度、中断和异常分派、多处理器同步。
    
- **设备驱动程序**：这些软件组件使操作系统能够与硬件设备进行交互。它们充当中介，允许系统管理和控制硬件和软件资源。
    
- **硬件抽象层（HAL）**：该组件为硬件设备和操作系统之间提供一个抽象层。它使软件开发人员能够以一致的、平台无关的方式与硬件交互。
    
- **窗口和图形系统（Win32k.sys）**：该子系统负责管理图形用户界面（GUI）并渲染屏幕上的视觉元素。

## WindowsAPI调用过程

恶意软件通常利用 Windows API 调用与系统交互并执行恶意操作。

让我们考虑一个 Windows API 调用流的示例，其中用户模式应用程序尝试使用 [ReadProcessMemory 函数](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory)访问特权作和系统资源。此函数允许进程读取不同进程的内存。

![[Pasted image 20250506032047.png]]

调用此函数时，还会向其传递一些必需的参数，例如目标进程的句柄、要从中读取的源地址、其自身内存空间中用于存储读取数据的缓冲区以及要读取的字节数。以下是 Microsoft 文档的`ReadProcessMemory`  WINAPI 函数语法。

```C
BOOL ReadProcessMemory(
  [in]  HANDLE  hProcess,
  [in]  LPCVOID lpBaseAddress,
  [out] LPVOID  lpBuffer,
  [in]  SIZE_T  nSize,
  [out] SIZE_T  *lpNumberOfBytesRead
);
```

`ReadProcessMemory` 是一个属于 `kernel32.dll` 库的Windows API函数。因此，该调用是通过 `kernel32.dll` 模块触发的，该模块作为Windows API的用户模式接口。在内部，`kernel32.dll` 模块与 `NTDLL.DLL` 模块进行交互，后者提供了与Windows内核的更低级别接口。然后，这个函数请求被转换为相应的本地API调用，即 `NtReadVirtualMemory`。以下是来自 `x64dbg` 的屏幕截图，展示了在调试器中的表现。

![[Pasted image 20250506032211.png]]

`NTDLL.DLL` 模块利用系统调用（syscalls）。

![[Pasted image 20250506032244.png]]
`syscall` 指令通过先前指令设置的参数触发系统调用。它将控制从用户模式转移到内核模式，内核在验证参数并检查调用进程的访问权限后执行请求的操作。

如果请求被授权，线程将从用户模式过渡到内核模式。内核维护一个称为系统服务描述符表（SSDT）或系统调用表（System Call Table）的表，该表是一个数据结构，包含指向各种系统服务例程的指针。这些例程负责处理用户模式应用程序发出的系统调用。系统调用表中的每个条目对应一个特定的系统调用号，关联的指针指向实现请求操作的相应内核函数。

负责 `ReadProcessMemory` 的系统调用在内核中执行，其中利用了Windows的内存管理和进程隔离机制。内核执行必要的验证、访问检查和内存操作，以读取目标进程的内存。内核检索与请求的虚拟地址对应的物理内存页，并将数据复制到提供的缓冲区中。

一旦内核完成读取内存，它将线程过渡回用户模式，并将控制权交还给原始的用户模式应用程序。应用程序然后可以访问从目标进程内存中读取的数据，并继续其执行。

## PE文件

Windows操作系统采用可移植可执行文件（PE）格式来封装可执行程序、DLL（动态链接库）和其他重要的系统组件。在恶意软件分析的领域中，对PE文件格式的深入理解是必不可少的。它可以让我们深入了解可执行文件的结构、操作以及文件中可能存在的恶意活动。

PE文件可以包含多种数据类型，包括可执行文件（.exe）、动态链接库（.dll）、内核模块（.srv）、控制面板应用程序（.cpl）等。PE文件格式本质上是一个数据结构，包含了Windows操作系统加载程序所需的关键信息，用于管理可执行代码并将其有效地加载到内存中。

### PE文件的各个部分

PE结构还包括一个**节表（Section Table）**，这是一个包含多个节的元素，每个节都有其特定的用途。节是文件的实际内容存储库，包括程序使用的数据、资源以及可执行代码。`.text`**节通常是分析时的重点**，因为它可能包含与注入攻击相关的伪造数据。

常见的PE节包括：

- **Text节（.text）**：存放程序的可执行代码。
    
- **Data节（.data）**：存储初始化的全局和静态数据变量。
    
- **只读初始化数据（.rdata）**：存储只读数据，如常量值、字符串文字和初始化的全局及静态变量。
    
- **异常信息（.pdata）**：用于异常处理的函数表条目集合。
    
- **BSS节（.bss）**：存储未初始化的全局和静态数据变量。
    
- **资源节（.rsrc）**：保存资源，如图像、图标、字符串和版本信息。
    
- **导入节（.idata）**：包含从其他DLL导入的函数信息。
    
- **导出节（.edata）**：包含可执行文件导出的函数信息。
    
- **重定位节（.reloc）**：包含在加载到不同内存地址时重定位可执行文件代码和数据的详细信息。
    

我们可以使用像**pestudio**这样的工具来可视化可移植可执行文件的各个节，如下所示。

![[Pasted image 20250506032510.png]]

### 进程

简单来说，进程是一个正在执行程序的实例。它代表了程序在内存中执行的一个切片，包含了各种资源，包括内存、文件句柄、线程和安全上下文。

进程在操作系统中是资源管理的基本单位。每个进程都有其独立的地址空间、数据、代码段以及执行路径。操作系统通过调度管理进程的生命周期，从启动到结束，以及在执行过程中如何分配和管理系统资源（如内存、CPU时间和文件访问）。

每个进程的特点：

- **唯一的PID（进程标识符）**：每个进程在操作系统中都会分配一个唯一的PID。这个数字标识符有助于操作系统跟踪和管理进程。
    
- **虚拟地址空间（VAS）**：在Windows操作系统中，每个进程都会分配独立的虚拟地址空间，为进程提供虚拟化的内存视图。VAS被划分为多个段，包括代码段、数据段和堆栈段，允许进程对内存进行隔离访问。
    
- **可执行代码（磁盘上的镜像文件）**：可执行代码，或镜像文件，指的是存储在磁盘上的二进制可执行文件。它包含了进程运行所需的指令和资源。
    
- **系统对象句柄表**：进程维护一个句柄表，这是各种系统对象的引用目录。系统对象可以包括文件、设备、注册表键、同步对象以及其他资源。
    
- **安全上下文（访问令牌）**：每个进程都有一个与之关联的安全上下文，体现为访问令牌（Access Token）。这个访问令牌封装了有关进程安全权限的信息，包括进程运行的用户帐户以及授予进程的访问权限。
    
- **一个或多个线程在其上下文中运行**：进程由一个或多个线程组成，线程是进程中执行的基本单元。线程使得进程可以并发执行，并支持多任务处理。
    

---

### 动态链接库（DLL）

动态链接库（DLL）是一种PE文件，代表了“Microsoft在Microsoft Windows操作系统中实现的共享库概念”。DLL暴露了一系列函数，这些函数可以被恶意软件利用，稍后我们将进一步探讨。首先，让我们解开DLL中的导入和导出函数。

#### 导入函数

导入函数是二进制文件在运行时动态链接到外部库或模块的功能。这些函数使得二进制文件能够利用这些库所提供的功能。

在恶意软件分析中，检查导入函数可能揭示恶意软件依赖的外部库或模块。这些信息有助于识别恶意软件可能与之交互的API，并且能揭示它所使用的资源，如文件系统、进程、注册表等。

通过识别特定的导入函数，可以推测恶意软件可以执行的操作，如文件操作、网络通信、注册表操作等。

导入函数的名称或哈希值可以帮助识别恶意软件变种或相关样本。

![[Pasted image 20250506032622.png]]
在这个图示中，恶意软件进程（`shell.exe`）执行进程注入，通过以下方式将代码注入到目标进程（`notepad.exe`）中，使用了从DLL `kernel32.dll` 导入的函数：

- **OpenProcess**：打开目标进程（`notepad.exe`）的句柄，提供必要的访问权限，以便操控其内存。
    
- **VirtualAllocEx**：在目标进程的地址空间中分配一块内存，用于存储注入的代码。
    
- **WriteProcessMemory**：将所需的代码写入目标进程的已分配内存块中。
    
- **CreateRemoteThread**：在目标进程中创建一个新的线程，指定注入代码的入口点作为新线程的起始位置。
    

因此，注入的代码将在目标进程的上下文中通过新创建的远程线程执行。这种技术使得恶意软件能够在目标进程中运行任意代码。

我们可以使用CFF Explorer来检查 `shell.exe`中的DLL导入，如下所示。

![[Pasted image 20250506032706.png]]

### 导出函数

导出函数是二进制文件为其他模块或应用程序提供使用的函数。

这些函数提供了一个接口，使得其他软件能够与该二进制文件进行交互。

在下面的截图中，我们可以看到DLL导入（使用CFF Explorer）和导出（使用x64dbg - Symbols选项卡）示例：

- **导入函数**：这部分展示了可执行文件`Utilman.exe`导入的DLL及其函数。
    
- **导出函数**：这部分展示了`Kernel32.dll` DLL导出的函数。
    

通过导入和导出函数的分析，可以进一步了解恶意软件或可执行文件如何与操作系统和其他程序交互，哪些功能是它与外部模块或应用共享的。

![[Pasted image 20250506032735.png]]

![[Pasted image 20250506032739.png]]

在恶意软件分析的背景下，理解导入和导出函数有助于揭示二进制文件的行为、功能以及它与外部实体的交互。这些信息对于威胁检测、恶意软件分类以及评估恶意软件对系统的影响至关重要。

具体来说，分析导入函数可以帮助识别恶意软件与哪些系统API或外部库进行交互，从而揭示它的潜在行为（如文件操作、网络通信、注册表访问等）。而分析导出函数则可以揭示该恶意软件提供给其他程序或模块的功能，这对于理解恶意软件可能与其他软件的协作方式非常有用。


## 计算哈希

### 文件哈希

VirusTotal 是一个在线恶意软件扫描引擎，可以通过搜索哈希来查找恶意软件。

在Windows上，我们使用powershell即可：

```powershell
Get-FileHash -Algorithm MD5 C:\wannacry.exe

Get-FileHash -Algorithm SHA256 C:\wannacry.exe
```

Linux上也很容易：

```shell
md5sum /home/wannacry.exe

```

```shell
sha256sum /home/wannacry.exe
```


![[Pasted image 20250506042906.png]]

当然，恶意软件作者只需做出一丁点细微更改，哈希就会完全不同。所以仅通过文件哈希来判断并不是那么的可靠。

### 导入哈希

**IMPHASH**，即“导入哈希”（Import Hash），是一种通过计算Windows可移植可执行文件（PE文件）中的导入函数来生成的加密哈希值。其算法首先将所有导入函数名称转换为小写字母。接着，DLL名称和函数名称被合并在一起，并按照字母顺序排列。最后，从生成的字符串中计算出一个MD5哈希值。因此，两个具有相同导入函数且顺序相同的PE文件将共享相同的IMPHASH值。

IMPHASH值通常可用于检测文件的相似性或标识相关样本。例如，如果两个文件具有相同的导入函数，它们可能是相同或非常相似的恶意软件变种。

我们也可以使用 `pefile` Python模块来计算文件的IMPHASH值：

```python
import sys
import pefile
import peutils

pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
imphash = pe.get_imphash()

print(imphash)
```


```bash
python imphash_calc.py wannacry.exe
9ecee117164e0b870a53dd187cdd7174
```

### 模糊哈希

**模糊哈希（SSDEEP）**，也称为**上下文触发分块哈希（CTPH）**，是一种哈希技术，旨在计算能够指示两个文件内容相似性的哈希值。该技术通过将文件划分为较小的固定大小的块，然后对每个块计算哈希值，最终将这些哈希值合并以生成最终的模糊哈希。

SSDEEP算法会对较长的相同块序列赋予更多权重，使其在识别经过小幅修改或相似但不完全相同的文件（例如不同版本的恶意样本）时非常有效。

我们可以在**VirusTotal**的“Details”标签中找到恶意软件的SSDEEP哈希。

#### 使用SSDEEP工具计算哈希值

```bash
ssdeep.exe C:\wannacry.exe
ssdeep,1.1--blocksize:hash:hash,filename
98304:wDqPoBhz1aRxcSUDk36SAEdhvxWa9P593R8yAVp2g3R:wDqPe1Cxcxk3ZAEUadzR8yc4gB,"C:\wannacry.exe"
```

在这个示例中，运行 `ssdeep.exe` 命令来计算 `Ransomware.wannacry.exe` 的SSDEEP哈希值。输出结果包括哈希值以及文件路径，如下所示：

```
98304:wDqPoBhz1aRxcSUDk36SAEdhvxWa9P593R8yAVp2g3R:wDqPe1Cxcxk3ZAEUadzR8yc4gB,"C:\Samples\MalwareAnalysis\Ransomware.wannacry.exe"
```

在SSDEEP中，可以使用命令行参数`-pb`来启动匹配模式（在存放恶意样本的目录下）。

```
ssdeep -pb * 
potato.exe matches svchost.exe (99)  
svchost.exe matches potato.exe (99)
```

在上述示例中，使用SSDEEP观察到两个恶意样本（`svchost.exe`和`potato.exe`）之间的相似度为99%。
### Section Hashing（PE段哈希）

**PE段哈希**，允许分析人员识别**PE中的已修改部分**。这对于识别恶意软件样本的微小变化尤其有用，这是攻击者常用的策略之一，用于避开检测。

#### 工作原理

段哈希技术计算PE文件每个部分（段）的加密哈希值。当比较两个PE文件时，如果两个文件中相应部分的哈希值匹配，则说明该部分在两个版本的文件中未被修改。

通过应用段哈希，安全分析人员可以识别出PE文件中被篡改或修改的部分。这有助于识别相似的恶意软件样本，即使它们经过轻微修改以规避基于签名的检测方法。

**pefile**模块可以用于执行段哈希：

```python
import sys
import pefile

pe_file = sys.argv[1]
pe = pefile.PE(pe_file)

for section in pe.sections:
    print(section.Name, "MD5 hash:", section.get_hash_md5())
    print(section.Name, "SHA256 hash:", section.get_hash_sha256())
```

恶意软件作者可能会使用一些技巧来规避此类分析，比如**段名混淆**或**动态生成段名**，从而试图绕过段哈希检查。

## 字符串

字符串可以提供有关恶意软件功能的线索。有时，我们可以从恶意软件样本中发现独特的嵌入字符串，例如：

- 嵌入的文件名（例如，被丢弃的文件）
    
- IP 地址或域名
    
- 注册表路径或键
    
- Windows API 函数
    
- 命令行参数
    
- 可能暗示特定攻击者的独特信息
    

Sysinternals 的 **strings** 工具可以用来显示恶意软件中包含的字符串。

```bash
strings C:\wannacry.exe
```

有时，字符串分析可以帮助将恶意软件样本与特定的攻击团体关联起来，如果发现显著的相似之处。例如，[在例子里]([The Little Ransomware That Couldn’t (Dharma) – The DFIR Report](https://thedfirreport.com/2020/06/16/the-little-ransomware-that-couldnt-dharma/))，包含 PDB 路径的字符串被用来将恶意软件样本与 Dharma/Crysis 勒索软件家族关联起来。

## UPX壳

我们可能会遇到一个经过压缩或混淆的恶意软件样本，这种技术被称为打包（加壳）。加壳有多个目的：
- 它混淆代码，使得更难以辨别其结构或功能。
    
- 它减少可执行文件的大小，使其更容易传输或更不显眼。
    
- 它通过阻碍传统的逆向工程尝试，使得安全研究人员难以分析。
    

这可能会妨碍字符串分析，因为对字符串的引用通常被隐藏或删除。同时，它还用一个压缩加载器存根替换或掩盖传统的 PE 部分，该存根从压缩数据部分中恢复原始代码。因此，恶意软件文件变得更小，且更难以分析，因为原始代码无法直接观察到。

一个流行的加壳工具是 **Ultimate Packer for Executables (UPX)**。

```cmd-session
strings C:\packed.exe

Strings v2.54 - Search for ANSI and Unicode strings in binary images.
Copyright (C) 1999-2021 Mark Russinovich
Sysinternals - www.sysinternals.com

!This program cannot be run in DOS mode.
UPX0
UPX1
UPX2
3.96
UPX!
ff.
8MZu
HcP<H
tY)
L~o
tK1
7c0
```

观察到输出中的字符串包含 **UPX**，并注意到其余的输出并未提供有关恶意软件功能的任何有价值信息。这表明，由于 UPX 打包，许多正常的字符串引用已被混淆或压缩，导致我们无法直接从字符串中获取有效的线索。

![[Pasted image 20250506050930.png]]

我们可以使用upx的官方工具脱壳：

```cmd-session
upx -d -o unpacked.exe C:\packed.exe
```


## 动态分析

在动态分析中，我们观察并解释恶意软件在运行时的行为，或在行动中的表现。这与静态分析形成鲜明对比，后者是在不执行恶意软件的情况下剖析其属性和内容。动态分析的主要目标是记录恶意软件对环境的实际影响。

在执行动态分析时，我们将恶意软件封装在一个严格控制、监控且通常是隔离的虚拟机（VM），恶意软件对其没有察觉。它认为自己正在与一个真实的系统互动，而我们记录其行为。

在设置好环境后，我们捕获系统的快照。这包括系统文件、注册表状态、正在运行的进程、网络配置等。这个基线作为参考点，用于识别恶意软件执行后对系统所做的更改。

为了有效捕获恶意软件的活动，我们部署各种监控和日志记录工具。例如，使用`Sysinternals`套件中的`Process Monitor（Procmon）`来记录系统调用、文件系统活动、注册表操作等。我们还可以使用`Wireshark、tcpdump和Fiddler`等工具来捕获网络流量，使用`Regshot`来拍摄执行前后的注册表快照。最后，使用`INetSim、FakeDNS`和`FakeNet-NG`等工具来模拟互联网服务。

恶意软件执行：在工具准备好并运行后，我们开始在隔离环境中执行恶意软件样本。在执行过程中，监控工具会捕获并记录所有活动，包括进程创建、文件和注册表修改、网络流量等。

观察和日志记录：允许恶意软件样本执行一段足够长的时间。期间，监控工具会仔细记录其每一个动作，这将为我们提供关于其行为和作案手法的全面洞察。

收集数据分析：在恶意软件执行完成后，我们停止其执行并关闭监控工具。我们现在开始检查收集的日志和数据，并将系统的状态与最初的基线进行比较，以识别恶意软件引入的变化。

在某些情况下，当恶意软件特别具有规避性或复杂时，我们可能会使用沙箱环境进行动态分析。沙箱如`Cuckoo Sandbox、Joe Sandbox`或`FireEye的Dynamic Threat Intelligence`云提供了一个自动化、安全且高度受控的恶意软件执行环境。它们配备了众多用于深入行为分析的功能，并生成关于恶意软件的网络行为、文件系统交互、内存占用等详细报告。

然而，一些高级恶意软件可以检测到沙箱环境并相应地改变其行为，这使得研究人员很难确定其真正的特征。

### **使用Noriben进行动态分析**

Noriben是我们动态分析工具包中的一款强大工具，实质上是Sysinternals ProcMon的Python包装器，一个全面的系统监控工具。

为了理解Noriben如何增强我们的动态分析工作，我们首先快速回顾一下ProcMon。这个来自Sysinternals套件的工具监视实时的文件系统、注册表和进程/线程活动。它结合了Filemon、Regmon等工具的功能，并提供了过滤、增强高亮和广泛的事件属性等高级功能，使其成为恶意软件分析中非常强大的系统监控工具。

然而，ProcMon收集的信息量庞大且广泛。没有适当的过滤和上下文分析，筛选这些原始数据会变得极为困难。这时，Noriben便发挥了作用。它利用ProcMon捕获系统事件，然后过滤和分析这些数据，以提取有意义的信息并精准地定位恶意活动。

在我们的动态恶意软件分析过程中，使用Noriben的步骤如下：

**设置Noriben**：我们通过命令行启动Noriben。例如，我们可以定义数据收集的持续时间、指定执行的恶意软件样本，或选择个性化的ProcMon配置文件。

**启动ProcMon**：启动后，Noriben会以预定义的配置启动ProcMon。该配置包含一组过滤器，用于排除正常的系统活动，并聚焦于可能的恶意行为。

**执行恶意软件样本**：在ProcMon运行时，Noriben执行选定的恶意软件样本。在此阶段，ProcMon会捕获所有系统活动，包括进程操作、文件系统更改和注册表修改等。

**监控和日志记录**：Noriben控制监控的持续时间，一旦完成，它会指示ProcMon将收集的数据保存为CSV文件，并终止ProcMon。

**数据分析与报告**：这正是Noriben的强大之处。它处理ProcMon生成的CSV文件，应用额外的过滤并进行上下文分析。Noriben会识别潜在的可疑活动，并将它们组织成不同类别，如文件系统活动、进程操作和网络连接。这个过程会生成一个清晰、可读的HTML或TXT格式报告，突出显示所分析恶意软件的行为特征。

Noriben与YARA规则的集成是另一个显著特点。我们可以利用YARA规则来增强数据过滤能力，更高效地识别感兴趣的模式。

为了演示，我们将对一个名为shell.exe的恶意软件样本进行动态分析，该样本位于本节目标机器的C:\Samples\MalwareAnalysis目录中。请按照以下步骤操作：

```bash
C:\Tools\Noriben-master> python .\Noriben.py
[*] Using filter file: ProcmonConfiguration.PMC
[*] Using procmon EXE: C:\ProgramData\chocolatey\bin\procmon.exe
[*] Procmon session saved to: Noriben_27_Jul_23__23_40_319983.pml
[*] Launching Procmon ...
[*] Procmon is running. Run your executable now.
[*] When runtime is complete, press CTRL+C to stop logging.
```

接下来，前往C:\Samples\MalwareAnalysis目录并双击激活shell.exe。shell.exe会识别到它正在沙箱中运行。关闭它所创建的窗口。停止ProcMon。在运行Noriben的命令提示符中，使用Ctrl+C命令停止它的操作。

```bash
C:\Tools\Noriben-master> python .\Noriben.py
[*] Using filter file: ProcmonConfiguration.PMC
[*] Using procmon EXE: C:\ProgramData\chocolatey\bin\procmon.exe
[*] Procmon session saved to: Noriben_27_Jul_23__23_40_319983.pml
[*] Launching Procmon ...
[*] Procmon is running. Run your executable now.
[*] When runtime is complete, press CTRL+C to stop logging.
[*] Termination of Procmon commencing... please wait
[*] Procmon terminated
[*] Saving report to: Noriben_27_Jul_23__23_42_335666.txt
[*] Saving timeline to: Noriben_27_Jul_23__23_42_335666_timeline.csv
[*] Exiting with error code: 0: Normal exit
```

你会发现，Noriben在其目录中生成了一个.txt报告，汇总了它所收集的所有行为信息。

![[Pasted image 20250506062953.png]]

Noriben 使用 ProcMon 捕获系统事件，但随后过滤并分析这些数据，以提取有意义的信息并找出恶意活动。它可能会过滤掉一些潜在有价值的信息。例如，我们从 Noriben 的报告中没有得到关于 shell.exe 如何识别其运行在沙箱或虚拟机中的任何有价值数据。

让我们采取不同的方法，手动启动 ProcMon（位于 C:\Tools\sysinternals）并使用其默认的、更加全面的配置。之后，重新运行 shell.exe。这可能会为我们提供关于 shell.exe 如何检测沙箱或虚拟机存在的信息。

接下来，让我们按如下配置设置过滤器（Ctrl+L），然后点击应用。

![[Pasted image 20250506063130.png]]

可以观察到，shell.exe 通过查询注册表中 VMware Tools 的存在来执行沙箱或虚拟机检测。

![[Pasted image 20250506063209.png]]